#!/usr/bin/env node

/**
 * Sync script for persistent documentation pages.
 *
 * Responsibilities:
 * 1) Parse page-index.yaml; validate unique ids, paths, and filenames.
 * 2) For each entry, ensure the page exists and frontmatter matches (id/title/summary/tags/updated).
 * 3) Fail on missing/extra pages or mismatches (unless --fix).
 * 4) Generate index.md sorted by title, with stamp "Last generated: <UTC ISO>".
 * 5) Prepend "<!-- DO NOT EDIT: generated by npm run docs:sync-index -->" to index.md.
 *
 * Fix mode:
 *   node scripts/sync-persistent-docs.js --fix
 *   - Updates page frontmatter to match page-index.yaml for known fields.
 *   - Generates index.md.
 */

const fs = require('fs');
const path = require('path');

let yaml;
try {
  yaml = require('js-yaml');
} catch (_e) {
  console.error('Error: js-yaml is not installed. Run: npm install');
  process.exit(1);
}

const ROOT_DIR = path.resolve(__dirname, '..');
const DOCS_DIR_POSIX = 'docs/persistent-memory/project-instructions';
const INDEX_YAML_PATH = path.join(ROOT_DIR, `${DOCS_DIR_POSIX}/page-index.yaml`);
const INDEX_MD_PATH = path.join(ROOT_DIR, `${DOCS_DIR_POSIX}/index.md`);

const args = process.argv.slice(2);
const FIX_MODE = args.includes('--fix');

function assertString(value, name, context) {
  if (typeof value !== 'string' || value.trim() === '') {
    throw new Error(`${context}: "${name}" must be a non-empty string`);
  }
}

function assertStringArray(value, name, context) {
  if (!Array.isArray(value) || value.length === 0) {
    throw new Error(`${context}: "${name}" must be a non-empty array of strings`);
  }
  for (const item of value) {
    if (typeof item !== 'string' || item.trim() === '') {
      throw new Error(`${context}: "${name}" must contain only non-empty strings`);
    }
  }
}

function toCanonicalIso(value, context) {
  const date =
    value instanceof Date
      ? value
      : typeof value === 'string'
        ? new Date(value)
        : null;

  if (!date || Number.isNaN(date.getTime())) {
    throw new Error(`${context}: "updated" must be a valid date/time`);
  }

  return date.toISOString();
}

function normalizePosixPath(p) {
  if (typeof p !== 'string') return '';
  return p.replaceAll('\\', '/');
}

function validateEntryShape(entry, index) {
  const context = `page-index.yaml entry #${index + 1}`;
  if (!entry || typeof entry !== 'object') {
    throw new Error(`${context}: entry must be an object`);
  }

  assertString(entry.id, 'id', context);
  assertString(entry.title, 'title', context);
  assertString(entry.path, 'path', context);
  assertString(entry.summary, 'summary', context);
  if (!('tags' in entry)) throw new Error(`${context}: "tags" is required`);
  assertStringArray(entry.tags, 'tags', context);
  if (!('updated' in entry)) throw new Error(`${context}: "updated" is required`);

  const normalizedPath = normalizePosixPath(entry.path);
  if (normalizedPath !== entry.path) {
    throw new Error(`${context}: "path" must use forward slashes (/) only`);
  }
  if (path.isAbsolute(entry.path) || entry.path.startsWith('../') || entry.path.includes('/../')) {
    throw new Error(`${context}: "path" must be a repo-relative path without ".." segments`);
  }
  if (!entry.path.startsWith(`${DOCS_DIR_POSIX}/`)) {
    throw new Error(
      `${context}: "path" must start with "${DOCS_DIR_POSIX}/" (got "${entry.path}")`,
    );
  }
  if (path.posix.dirname(entry.path) !== DOCS_DIR_POSIX) {
    throw new Error(
      `${context}: "path" must be directly under "${DOCS_DIR_POSIX}/" (got "${entry.path}")`,
    );
  }
  if (!entry.path.endsWith('.md')) {
    throw new Error(`${context}: "path" must end with ".md" (got "${entry.path}")`);
  }
  if (path.posix.basename(entry.path) === 'index.md') {
    throw new Error(`${context}: "path" must not point to index.md`);
  }

  // Validate "updated" is parseable (canonicalization happens when writing frontmatter).
  toCanonicalIso(entry.updated, context);
}

function parseFrontmatter(content, filePath) {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
  const match = content.match(frontmatterRegex);
  if (!match) return null;

  try {
    const frontmatter = yaml.load(match[1], { schema: yaml.FAILSAFE_SCHEMA }) ?? null;
    if (!frontmatter || typeof frontmatter !== 'object') return null;
    return frontmatter;
  } catch (error) {
    throw new Error(
      `Failed to parse frontmatter in ${filePath}: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

function buildFrontmatterYaml(entry) {
  const fm = {
    id: entry.id,
    title: entry.title,
    summary: entry.summary,
    tags: entry.tags,
    updated: toCanonicalIso(entry.updated, `page-index.yaml entry "${entry.id}"`),
  };

  return yaml.dump(fm, { lineWidth: 0, sortKeys: false }).trimEnd();
}

function replaceOrAddFrontmatter(fileContent, entry) {
  const fmYaml = buildFrontmatterYaml(entry);
  const fmBlock = `---\n${fmYaml}\n---\n\n`;

  const frontmatterRegex = /^---\s*\n[\s\S]*?\n---\s*\n/;
  if (frontmatterRegex.test(fileContent)) {
    return fileContent.replace(frontmatterRegex, fmBlock);
  }

  if (fileContent.trim().length === 0) {
    return fmBlock;
  }

  return `${fmBlock}${fileContent.replace(/^\uFEFF?/, '')}`;
}

function normalizeTagsForCompare(tags) {
  return [...tags].map((t) => t.toLowerCase()).sort();
}

function validateOrFixPage(entry, filePath) {
  const pageContent = fs.readFileSync(filePath, 'utf-8');
  const frontmatter = parseFrontmatter(pageContent, filePath);

  if (!frontmatter) {
    if (!FIX_MODE) {
      throw new Error(`Missing or invalid frontmatter in ${filePath}`);
    }
    const updatedContent = replaceOrAddFrontmatter(pageContent, entry);
    fs.writeFileSync(filePath, updatedContent, 'utf-8');
    return { fixed: true };
  }

  const context = `${filePath}`;
  assertString(frontmatter.id, 'id', context);
  assertString(frontmatter.title, 'title', context);
  assertString(frontmatter.summary, 'summary', context);
  if (!('tags' in frontmatter)) throw new Error(`${context}: "tags" is required in frontmatter`);
  assertStringArray(frontmatter.tags, 'tags', context);
  if (!('updated' in frontmatter)) {
    throw new Error(`${context}: "updated" is required in frontmatter`);
  }

  const expectedUpdated = toCanonicalIso(entry.updated, `page-index.yaml entry "${entry.id}"`);
  const actualUpdated = toCanonicalIso(frontmatter.updated, `${filePath} frontmatter`);

  const mismatches = [];
  if (entry.id !== frontmatter.id) mismatches.push('id');
  if (entry.title !== frontmatter.title) mismatches.push('title');
  if (entry.summary !== frontmatter.summary) mismatches.push('summary');

  const expectedTags = normalizeTagsForCompare(entry.tags);
  const actualTags = normalizeTagsForCompare(frontmatter.tags);
  if (JSON.stringify(expectedTags) !== JSON.stringify(actualTags)) mismatches.push('tags');

  if (expectedUpdated !== actualUpdated) mismatches.push('updated');
  if (typeof frontmatter.updated === 'string' && frontmatter.updated !== expectedUpdated) {
    if (!mismatches.includes('updated')) mismatches.push('updated');
  }

  if (mismatches.length === 0) return { fixed: false };

  if (!FIX_MODE) {
    throw new Error(`Mismatch in ${filePath}: ${mismatches.join(', ')}`);
  }

  const updatedContent = replaceOrAddFrontmatter(pageContent, entry);
  fs.writeFileSync(filePath, updatedContent, 'utf-8');
  return { fixed: true };
}

function generateIndex(entries) {
  const sortedEntries = [...entries].sort((a, b) => a.title.localeCompare(b.title));
  const timestamp = new Date().toISOString();

  let content = '<!-- DO NOT EDIT: generated by npm run docs:sync-index -->\n\n';
  content += '# Project Instructions Index\n\n';
  content += `_Last generated: ${timestamp}_\n\n`;

  for (const entry of sortedEntries) {
    const linkTarget = path.posix.basename(entry.path);
    content += `## [${entry.title}](${linkTarget})\n\n`;
    content += `${entry.summary}\n\n`;
    content += `**Tags:** ${entry.tags.join(', ')}\n\n`;
  }

  return content;
}

function main() {
  const indexYamlContent = fs.readFileSync(INDEX_YAML_PATH, 'utf-8');
  const entries = yaml.load(indexYamlContent, { schema: yaml.FAILSAFE_SCHEMA });
  if (!Array.isArray(entries)) {
    throw new Error('page-index.yaml must contain an array of entries');
  }

  entries.forEach((entry, i) => validateEntryShape(entry, i));

  const ids = new Set();
  const paths = new Set();
  const filenames = new Set();
  const duplicateIds = new Set();
  const duplicatePaths = new Set();
  const duplicateFilenames = new Set();

  for (const entry of entries) {
    if (ids.has(entry.id)) duplicateIds.add(entry.id);
    ids.add(entry.id);

    if (paths.has(entry.path)) duplicatePaths.add(entry.path);
    paths.add(entry.path);

    const filename = path.posix.basename(entry.path);
    if (filenames.has(filename)) duplicateFilenames.add(filename);
    filenames.add(filename);
  }

  if (duplicateIds.size > 0) {
    throw new Error(`Duplicate IDs found in page-index.yaml: ${[...duplicateIds].join(', ')}`);
  }
  if (duplicatePaths.size > 0) {
    throw new Error(`Duplicate paths found in page-index.yaml: ${[...duplicatePaths].join(', ')}`);
  }
  if (duplicateFilenames.size > 0) {
    throw new Error(
      `Duplicate filenames found in page-index.yaml: ${[...duplicateFilenames].join(', ')}`,
    );
  }

  let fixedCount = 0;
  for (const entry of entries) {
    const absPath = path.join(ROOT_DIR, entry.path);
    if (!fs.existsSync(absPath)) {
      throw new Error(`Page not found: ${absPath}`);
    }
    const result = validateOrFixPage(entry, absPath);
    if (result.fixed) fixedCount += 1;
  }

  // Extra pages (non-recursive).
  const docsDirAbs = path.join(ROOT_DIR, DOCS_DIR_POSIX);
  const files = fs.readdirSync(docsDirAbs);
  const markdownFiles = files.filter((f) => f.endsWith('.md') && f !== 'index.md');
  const extraFiles = markdownFiles.filter((f) => !filenames.has(f));
  if (extraFiles.length > 0) {
    throw new Error(`Extra pages found that are not in page-index.yaml: ${extraFiles.join(', ')}`);
  }

  const indexContent = generateIndex(entries);
  fs.writeFileSync(INDEX_MD_PATH, indexContent, 'utf-8');

  const prefix = FIX_MODE ? '✓ Fixed and synced' : '✓ Successfully synced';
  console.log(`${prefix} ${entries.length} pages`);
  if (FIX_MODE) console.log(`✓ Updated frontmatter in ${fixedCount} file(s)`);
  console.log('✓ Generated index.md');
}

try {
  main();
} catch (error) {
  console.error('Error:', error instanceof Error ? error.message : String(error));
  process.exitCode = 1;
}
